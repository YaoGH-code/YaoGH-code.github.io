
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"","date":1682985600,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1682985600,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"Yao (John) Xu","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature. Slides can be added in a few ways:\nCreate slides using Wowchemy’s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes. Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"http://yaogh-code.github.io/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":["Yao (John) Xu"],"categories":["Operating System"],"content":"Repo Link https://github.com/YaoGH-code/OS\nOverview entry.S As per the specifications mentioned in the linker script, the RAM in the system begins at the physical address 0x80000000. It has a total size of 128 megabytes (128M). The specific memory layout is determined by the way QEMU simulates the memory in the system.\nOnce the boot loader successfully loads the kernel into the RAM, the execution of the system starts from the entry.S file. This file serves as the entry point of the kernel code.\n.section .text .global _entry _entry: /* basically adding a offset ((mhartid+1)*4096) to find the starting address of each hart */ la sp, stack0 # load the address of symbol stack0 to sp register li a0, 4096 # load the immediate to a0 register /* csrr: Control and Status Register Read The mhartid CSR is an XLEN-bit read-only register containing the integer ID of the hardware thread running the code. This register must be readable in any implementation. Hart IDs might not necessarily be numbered contiguously in a multiprocessor system, but at least one hart must have a hart ID of zero. mhartid -\u0026gt; Machine Hart ID -\u0026gt; to identify currently running thread Hart -\u0026gt; Hardware Thread */ csrr a1, mhartid addi a1, a1, 1 # a1 += 1 mul a0, a0, a1 # a0 *= a1 add sp, sp, a0 # sp += a0 call start # go to start in start.c The purpose of the code snippet is to load the address of an initial stack for each core into the sp (stack pointer) register. This allows for a smooth transition to the C code in the start.c file. In start.c, the stack is defined as an array, and each core can utilize a portion of this array as its stack.\nAbout PLIC - Platform Level Interrupt Controller Interrupts are events that occur in computer systems when certain devices or processes require immediate attention from the CPU. These devices can include input devices like keyboards or disks. When an interrupt is generated, it signals the CPU to temporarily pause its current execution and handle the interrupt request. When an interrupt occurs, a specific bit called the interrupt pending bit associated with the corresponding device is set. All cores that have that particular device enabled are notified, causing a trap or exception to be triggered. This trap transfers control to the interrupt handler, which is responsible for processing the interrupt. To determine which device caused the interrupt, the trap handler reads a memory-mapped register in the Platform-Level Interrupt Controller (PLIC). This register contains information about the interrupting device, and the handler retrieves the ID associated with that device. Additionally, the PLIC clears the interrupt pending bit for that device. Each device is assigned a unique device number, and cores can be interrupted in different modes, such as machine, supervisor, or user mode. Moreover, each device is assigned a priority, while each core is allocated a threshold value. Only devices with a priority higher than the core’s threshold can generate interrupts and interrupt the core’s ongoing operations. This prioritization helps ensure that critical or time-sensitive events take precedence over less important ones.\nIn the plic_init function, the device priority for the UART and disk is set to 1. This indicates that these devices have a higher priority compared to others in the system. Setting priorities helps determine the order in which interrupts are handled. In the plic_init_hart function, the interrupt matrix is updated to enable interrupts from the disk and UART devices for a specific core. This means that this particular core is now capable of receiving and processing interrupts from these devices. Furthermore, the priority threshold for the core is set to 0. This threshold determines which interrupts can interrupt the core’s ongoing operations. By setting it to 0, no interrupts are blocked based on their priority. This ensures that all interrupts from enabled devices will be serviced by the core. The interrupt_claim and interrupt_complete functions are used by a core to claim an interrupt and mark its completion. When an interrupt occurs, the core can use the interrupt_claim function to indicate that it will handle the interrupt. Once the interrupt service routine is completed, the interrupt_complete function is called to notify the PLIC that the interrupt has been serviced and can be cleared.\n/** * Each PLIC interrupt source can be assigned a priority * by writing to its 32-bit memory-mapped priority * register. The FU540-C000 supports 7 levels of * priority. A priority value of 0 is reserved to mean * \u0026#34;never interrupt\u0026#34; and effectively disables the * interrupt. Priority 1 is the lowest active priority, * and priority 7 is the highest. Ties between global * interrupts of the same priority are broken by the * Interrupt ID; interrupts with the lowest ID have the * highest effective priority. * Here, we set the device priority of UART and disk to 1. */ void plic_init(){ …","date":1682985600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682985600,"objectID":"1fe1424980ed6c7a61df434bbd09918d","permalink":"http://yaogh-code.github.io/post/os/","publishdate":"2023-05-02T00:00:00Z","relpermalink":"/post/os/","section":"post","summary":"Implementation notes of the OS","tags":["Academic","Open Source"],"title":"RISC-V OS Kernel Rewrite Based on MIT Xv6","type":"post"},{"authors":["Yao (John) Xu"],"categories":["Operating System","Parallel Computing"],"content":"Repo Link https://github.com/YaoGH-code/uthread\nOverview This project aims to provide a robust preemptive user-level thread library that simplifies the creation and management of user-level threads. By utilizing interfaces such as “uthread_create” and “uthread_join,” users familiar with POSIX threads can easily develop programs with user-level parallelism. The context of user-level threads in this project is implemented through a combination of our custom “uthread” data structure and the “ucontext” functionality provided by POSIX. Additionally, a lock-free data structure is employed to maintain each worker thread efficiently. The scheduling of user threads relies heavily on signals in this project. When a signal arrives, it indicates the start of the next scheduling round for each worker thread. The stack prepared by the kernel for the signal handler is crucial for smooth context switching. To ensure thread safety at the user level, interfaces such as “umalloc,” “uprintf,” and “uthread_mutex_lock” are provided. These interfaces facilitate safe memory allocation, printing, and mutual exclusion. This thread library is compatible with machines running MacOS or Linux with x86 architecture CPUs. Extensive testing has been conducted to verify the correctness and scalability of the system.\nBackground With the increasing prevalence of multi-core processors, high-performance computing demands, scalability requirements, user expectations for responsiveness, and cost-efficiency considerations, concurrent programming has become increasingly essential. To achieve concurrency, multi-threading has emerged as a popular approach, primarily due to its ability to leverage the shared memory model and its lower resource consumption. POSIX threads (pthreads) have gained widespread adoption for multi-threading implementations due to their efficiency, scalability, reliability, and broad support across various operating systems. However, effectively harnessing pthreads for efficient concurrency still presents significant challenges.\nOne challenge arises when the number of concurrent tasks increases, potentially causing significant scheduling overhead and overwhelming hardware resources. The thread pool technique has long been used to address this issue, where it abstracts each concurrent task into a unit of work and adds it to a shared work queue. From this queue, threads in the pool grab one unit of work and finish executing it, then proceed to the next until the queue is empty. The thread pool can be a neat solution to deal with a huge quantity of tasks while keeping the scheduling overhead bounded. However, it may be insufficient when the running spans of each concurrent task are highly variable. This is especially true if we aim to achieve user-level multitasking, where we can have long-running or persistent tasks. The thread pool may not be a wise solution here, as the tasks that run much longer than the others can cause drastic delay to those far down in the queue, which, in the worst case, may never be executed. That’s because in the thread pool model subsequent tasks are not executed until all preceding tasks have been completed. If we were still to use pthreads naively, we would end up spawning hundreds of threads again, one for each task, producing immense overhead and hurting performance.\nClearly, the thread pool model should be preserved. But how to break the execution of long-running blocking tasks without compromising correctness to allow other tasks to run? To answer this question, we must introduce the idea of user-level threads. In this project, we turn each unit of work in the work queue into an execution context. Each worker thread (POSIX thread) has a task queue stores user level tasks that assigned to it when user create a user level thread with uthread create. These user level tasks are structures where we turn each unit of work in the work queue (we are still sticking to the thread pool model) into an execution context, keeping track of the full state of each concurrently running task, and instead of mapping one task to one dedicated POSIX thread, we dynamically decide which POSIX thread in the pool should execute which task, so that we can safely break the execution of one task, saving its context back to the shared queue, and start the execution of the next user-level thread, loading the corresponding context from the queue.\nApproach Before going into the core part of this project, some initialization and helper function will be introduced first. This user level thread library requires some initialization before starting to create and schedule user level threads. The runtime start function shown below is the first function will be called to initialize a structure called runtime which is defined in uthread.c file that contains some run time information. First, there will be only one thread enter this function. We record this main thread as the master worker thread (pthread) and mark the start flag to one so …","date":1682899200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682899200,"objectID":"8b3621a7d9b5f8e4e83360edae723b4f","permalink":"http://yaogh-code.github.io/post/uthread/","publishdate":"2023-05-01T00:00:00Z","relpermalink":"/post/uthread/","section":"post","summary":"CMU 15-618 Parallel Computer Architecture and Programming final project","tags":["Academic","Open Source"],"title":"A Preemptive User-Level Thread Library","type":"post"},{"authors":["Yao (John) Xu"],"categories":["Learning notes"],"content":"1. Two Sum Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.\n/* Solution: Loop through all elements in the nums array. If the number we want is in the hash map, then we return the val(index) of the key(target-nums[i]) and the current index. Otherwise, we add that key-val into the hash map. Finally, there is no such number in the array, return empty array. */ class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt; M; for(int i=0; i\u0026lt;nums.size(); i++){ if (M.count(target-nums[i])) return {i, M[target-nums[i]]}; else M[nums[i]] = i; } return {}; } }; 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. ex: 2-\u0026gt;4-\u0026gt;3 5-\u0026gt;6-\u0026gt;4 7-\u0026gt;0-\u0026gt;8 /* Solution: We have two linked lists for two numbers. We loop through two linked lists in the while loop and compute a temp sum for each digit (also include the carry) and add new node which representing a digit in the new number to the output linked list. Also, updates the carry for the next iteration. */ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* dummy_head = new ListNode(-1); ListNode* current = dummy_head; int carry=0; while(l1 || l2 || carry){ int sum=0; if(l1){ sum += l1-\u0026gt;val; l1 = l1-\u0026gt;next; } if(l2){ sum += l2-\u0026gt;val; l2 = l2-\u0026gt;next; } sum += carry; ListNode* node = new ListNode(sum%10); carry = sum/10; current-\u0026gt;next = node; current = current-\u0026gt;next; } return dummy_head-\u0026gt;next; } }; 3. Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating characters.\n/* Solution: The key point is to correctly kepp track of the left pointer. If we do not use max(left, M[s[i]]+1), we might cover a string with repeated char that we have identiftied before (ex. abba) which is wrong so we cannot let left pointer goes backward to cover substring with potential repeated char. */ //we cannot move the left back //abba class Solution { public: int lengthOfLongestSubstring(string s) { if (!s.size()) return 0; unordered_map\u0026lt;char, int\u0026gt; m; int max_len = 1; int left = 0; for (int i=0; i\u0026lt;s.length(); i++){ if (m.count(s[i])){ left = max(left, m[s[i]]+1); } m[s[i]] = i; max_len = max(max_len, i-left+1); } return max_len; } }; 5. Longest Palindromic Substring Given a string s, return the longest palindromic substring in s.\n/* Solution: helper function: expand from a \u0026#34;pivot\u0026#34; to both sides and try to find the longest palindromic substring. There are two cases: substring with odd number of chars and substring with even number of chars. If the new substring is longer, update the starting point and length. */ class Solution { public: int helper(int l, int r, string s){ while(l\u0026gt;=0 \u0026amp;\u0026amp; r\u0026lt;s.length() \u0026amp;\u0026amp; s[l]==s[r]){ l--; r++; } return r-l-1; } string longestPalindrome(string s) { int n=s.length(); int len=0; int start=0; for (int i=0; i\u0026lt;n; i++){ int cur = max(helper(i,i,s), helper(i,i+1,s)); if (cur\u0026gt;len){ len=cur; start = i-(len-1)/2; } } return s.substr(start,len); } }; 6. Zigzag Conversion The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: “PAHNAPLSIIGYIR”\n/* Solution: Prepare n strings and fill them with different levels. For example, level 0,1,2... if we reached the lowest or highest level, change the direction. Finally, put all level of strings together. */ class Solution { public: string convert(string s, int n) { if(n==1) return s; vector\u0026lt;string\u0026gt; v(n); int level = 0; int dir = 1; string res; for (int i=0; i\u0026lt;s.length(); i++){ v[level]+=s[i]; if (dir) level++; else level--; if (level == n-1) dir=0; if (level == 0) dir=1; } for (string s:v) res+=s; return res; } }; 7. Reverse Integer Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nclass Solution { public: int reverse(int x) { long long res = 0; while(x) { res = res*10 + x%10; x /= 10; } return (res\u0026lt;INT_MIN || res\u0026gt;INT_MAX) ? 0 : res; } }; 9. Palindrome Number Given an integer x, return true if x is a palindrome, and false otherwise.\nclass Solution { public: bool isPalindrome(int x) { if( x\u0026lt;0 || ( x % 10==0 \u0026amp;\u0026amp; x!=0)) return …","date":1682848800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682848800,"objectID":"e38d3482014a56edb2e5a7d9b068c7ba","permalink":"http://yaogh-code.github.io/post/leetcode/","publishdate":"2023-04-30T10:00:00Z","relpermalink":"/post/leetcode/","section":"post","summary":"Learning notes about Leetcode Questions","tags":["Academic","Learning notes"],"title":"Data Structures and Algorithms (C++)","type":"post"},{"authors":["Yao (John) Xu"],"categories":["Operating System","C Programming"],"content":"Repo Link: https://github.com/YaoGH-code/MemSim\nOverview ","date":1682820000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682820000,"objectID":"a6dbda7f61dfb17a4832099b9de27242","permalink":"http://yaogh-code.github.io/post/vmp_sim/","publishdate":"2023-04-30T02:00:00Z","relpermalink":"/post/vmp_sim/","section":"post","summary":"The C implementation of a virtual memory and process scheduling simulator","tags":["Academic","Open Source"],"title":"A Simulator of Virtual Memory and Process Scheduling","type":"post"},{"authors":["Yao (John) Xu"],"categories":["CPU design","Computer Architecture","Verilog"],"content":"Repo Link https://github.com/YaoGH-code/mCPU\nIntroduction The MIPS (Microprocessor without Interlocked Pipeline Stages) architecture is a reduced instruction set computer (RISC) architecture that has played a significant role in the development of microprocessors. MIPS architecture features a clean and streamlined instruction set, emphasizing simplicity and efficiency. It focuses on optimizing the performance of frequently used instructions, making it suitable for a wide range of applications, including embedded systems, consumer electronics, networking equipment, and high-performance computing.\nOne of the distinguishing characteristics of MIPS is its fixed instruction format, where instructions are encoded in a 32-bit word. This fixed-format allows for efficient decoding and pipelining, enabling high-performance execution and reducing the complexity of the microarchitecture. MIPS processors employ a five-stage pipeline, including instruction fetch, instruction decode, execution, memory access, and write-back. This pipelining technique enables instructions to be processed concurrently, maximizing the overall throughput of the processor.\nDesign The picture above shows the structure and components of this CPU. This CPU is composed of 5 stages, which are: Instruction Fetch(IF), Instruction Decode(ID), Execution(EXE), Memory(MEM) and Write Back(WB) stage.\nIF Stage The Instruction Fetch stage consists of three components. Firstly, there is the program counter register, which holds the physical address of the next instruction in the instruction memory (represented here as a simplified memory structure). In each cycle, an adder increments the address by 4, and the resulting address is stored in the program counter for the next clock cycle. Simultaneously, the instruction memory, equipped with an input port and an output port, fetches an instruction using the address from the program counter. This fetched instruction is then stored in the IF/ID register during the same cycle.\nID Stage In the instruction decoding stage, we can clearly see the connection between the instruction set and the actual electronic circuit. First, the instruction will be decoded into following components:\nop code: basic operation of the instruction rs: the first register source operand rt: the second register source operand rd: the register destination operand shamt: shift amount to be used in shift instructions funct code: function code imm: immediate value Combining the Op code (bits 31-26) and funct code (bits 5-0) in MIPS instructions enables the hardware to determine the current instruction and its corresponding function. For example, instructions for basic arithmetic operation(R-format) have the same op code 0x0 but with a different funct code. So, Op code and funct code combined will be provided to the control unit for generating control signals for later stages. These control signals will be covered later.\nThere is also a MUX in the MIPS architecture that utilizes the control signal “regrt” to select either the “rd” or “rt” register. The selected signal, along with the data to be written back to the register file, is then passed back to the ID stage. This MUX serves the purpose of determining the appropriate destination for the write-back operation. For instance, instructions with an opcode of 0 will select the “rd” register as the destination. On the other hand, for the LW (Load Word) instruction, the data retrieved from the data memory during the MEM stage will be written back to the register specified by the “rt” register. Therefore, the MUX helps decide which part of the instruction contains the desired destination for the write-back operation.\nThe signals “rs” and “rt” are used to access the register file and read the data stored in registers “rs” and “rt” simultaneously through the “qa” and “qb” ports. Additionally, the immediate value (imm) is sign extended and passed to the ALU for computation. This computation takes place during the EXE stage, where the ALU performs operations using the immediate value and other relevant data.\nThen, let’s look at the control signals generated by the control unit:\nwreg: A write back to register will happen in the lifecycle of the current instruction m2reg: A write back to register with data in memory will happen in the lifecycle of the current instruction wmem: A write to memory will happen in the lifecycle of the current instruction aluc: ALU operation mode ex. if aluc==b0010, then ALU_out \u0026lt;= ALU_a + ALU_b; aluimm: A immediate value is needed by the ALU to finish this operation EXE Stage In the EXE (Execute) stage, two signals are employed to control the ALU’s input sources and operation mode. Firstly, the “ealuc” signal is utilized to select the desired operation mode for the ALU. For instance, a value of “b0010” would indicate that the ALU should perform an addition operation on its two input numbers.\nSecondly, the “ealuimm” signal determines the source of the input port “b” of the ALU. …","date":1682812800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682812800,"objectID":"e4519e50a6915a7d300d74618bf3a90a","permalink":"http://yaogh-code.github.io/post/mcpu/","publishdate":"2023-04-30T00:00:00Z","relpermalink":"/post/mcpu/","section":"post","summary":"A 5-stage pipeline MIPS CPU implemented in Verilog","tags":["Academic","Open Source"],"title":"A 5-stage pipeline MIPS CPU","type":"post"},{"authors":["Yao (John) Xu"],"categories":["Learning notes"],"content":" 1. Introduction The make utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them. You need a file called a makefile to tell make what to do. Most often, the makefile tells make how to compile and link a program.\nSyntax A Makefile contains some rules with the following shape:\ntarget … : prerequisites … recipe … … A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’. The prerequisites are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called dependencies. The commands are a series of steps typically used to make the target(s). These need to start with a tab character, not spaces. Here is a typical Makefile - one that compiles a single C file:\ntest: cc test.c -o test We can simply running make. Since there’s no target supplied as an argument to the make command, the first target is run. In this case, there’s only one target (test). The first time you run this, test will be created. The second time, you’ll see make: ’test’ is up to date. That’s because the test file already exists. But there’s a problem: if we modify test.c and then run make, nothing gets recompiled.\nInstead, we can do this:\ntest: test.c cc test.c -o test When we run make again, the following set of steps happens:\nThe first target is selected, because the first target is the default target This has a prerequisite of test.c Make decides if it should run the test target. It will only run if test doesn’t exist, or test.c is newer than test. Here is a more complicated example:\nedit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o Edit is a target that requires eight prerequisites. The command is to compile executable file “edit” with eight object files. Each of the object file requires some C files and header files. We do not need to include header file name in the command since it is already included in the C file and the purpose to include header files in the prerequisites is to make sure the file is already there, just like a additional verification.\nWhen a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first. In this example, edit depends on each of the eight object files; the object file main.o depends on the source file main.c and on the header file defs.h.\nMake clean The target ‘clean’ is not a file, but merely the name of an action. Since you normally do not want to carry out the actions in this rule, ‘clean’ is not a prerequisite of any other rule. Consequently, make never does anything with it unless you tell it specifically. Note that this rule not only is not a prerequisite, it also does not have any prerequisites, so the only purpose of the rule is to run the specified recipe. Targets that do not refer to files but are just actions are called phony targets.\nVariables If a new object file is added to the system, we might add it to one list and forget the other, such duplication is error-prone. Instead, we can do this:\nobjects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit $(objects) Other examples of using variables:\na := one two # a is assigned to the string \u0026#34;one two\u0026#34; all: printf \u0026#39;$a\u0026#39; x := dude all: echo $(x) echo ${x} Letting make Deduce the Recipes It is not necessary to spell out the recipes for compiling the individual C source files, because make can figure them out: it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command. For example, it will use the recipe ‘cc -c main.c -o main.o’ to compile main.c into main.o. We can therefore omit the recipes from the rules for the object files.\nWhen a ‘.c’ file is used automatically in this way, …","date":1682726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1682726400,"objectID":"0d2ed62a94a6dcef9e4b04b45a393774","permalink":"http://yaogh-code.github.io/post/makefile/","publishdate":"2023-04-29T00:00:00Z","relpermalink":"/post/makefile/","section":"post","summary":"Learning notes about make","tags":["Academic","Learning notes"],"title":"About Make","type":"post"},{"authors":["Yao (John) Xu"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"http://yaogh-code.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"http://yaogh-code.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"http://yaogh-code.github.io/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Example Project","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"http://yaogh-code.github.io/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":["Yao (John) Xu","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"http://yaogh-code.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Yao (John) Xu","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"http://yaogh-code.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"}]