<!DOCTYPE html>
<!-- This site was created with Wowchemy. https://www.wowchemy.com -->
<!-- Last Published: July 9, 2023 --><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.7.0 for Hugo" />
  

  
  












  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.16f785cdb553c8c4431db6775122af35.css" media="print" onload="this.media='all'">

  
  
  
    
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.2/css/academicons.min.css" integrity="sha512-KlJCpRsLf+KKu2VQa5vmRuClRFjxc5lXO03ixZt82HZUk41+1I0bD8KBSA0fY290ayMfWYI9udIqeOWSu1/uZg==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    
    
    
    
      
      
    
    
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.0f229d4b7ebad1917a9a357cba2effab.css" />

  
  
  

  
  
  
  
  
  
  
    
    
    <link rel="stylesheet" href="/css/libs/chroma/github-light.min.css" title="hl-light" media="print" onload="this.media='all'" >
    <link rel="stylesheet" href="/css/libs/chroma/dracula.min.css" title="hl-dark" media="print" onload="this.media='all'" disabled>
  

  
  


























  
  
  






  <meta name="author" content="Yao (John) Xu" />





  

<meta name="description" content="Implementation notes of the OS" />



<link rel="alternate" hreflang="en-us" href="http://yaogh-code.github.io/post/os/" />
<link rel="canonical" href="http://yaogh-code.github.io/post/os/" />



  <link rel="manifest" href="/manifest.webmanifest" />



<link rel="icon" type="image/png" href="/media/icon_hu3fa31baf23334842a6c8f8d4ce717078_16335_32x32_fill_lanczos_center_3.png" />
<link rel="apple-touch-icon" type="image/png" href="/media/icon_hu3fa31baf23334842a6c8f8d4ce717078_16335_180x180_fill_lanczos_center_3.png" />

<meta name="theme-color" content="#1565c0" />










  






<meta property="twitter:card" content="summary_large_image" />

  <meta property="twitter:site" content="@wowchemy" />
  <meta property="twitter:creator" content="@wowchemy" />
<meta property="twitter:image" content="http://yaogh-code.github.io/post/os/featured.png" />
<meta property="og:site_name" content="Yao Xu" />
<meta property="og:url" content="http://yaogh-code.github.io/post/os/" />
<meta property="og:title" content="RISC-V OS Kernel Rewrite Based on MIT Xv6 | Yao Xu" />
<meta property="og:description" content="Implementation notes of the OS" /><meta property="og:image" content="http://yaogh-code.github.io/post/os/featured.png" /><meta property="og:locale" content="en-us" />

  
    <meta
      property="article:published_time"
      content="2023-05-02T00:00:00&#43;00:00"
    />
  
  
    <meta property="article:modified_time" content="2023-05-02T00:00:00&#43;00:00">
  






    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://yaogh-code.github.io/post/os/"
  },
  "headline": "RISC-V OS Kernel Rewrite Based on MIT Xv6",
  
  "image": [
    "http://yaogh-code.github.io/post/os/featured.png"
  ],
  
  "datePublished": "2023-05-02T00:00:00Z",
  "dateModified": "2023-05-02T00:00:00Z",
  
  "author": {
    "@type": "Person",
    "name": "Yao (John) Xu"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "Yao Xu",
    "logo": {
      "@type": "ImageObject",
      "url": "http://yaogh-code.github.io/media/icon_hu3fa31baf23334842a6c8f8d4ce717078_16335_192x192_fill_lanczos_center_3.png"
    }
  },
  "description": "Implementation notes of the OS"
}
</script>

  

  




  
  
  

  
  

  


  
  <title>RISC-V OS Kernel Rewrite Based on MIT Xv6 | Yao Xu</title>

  
  
  
  











</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="1fe1424980ed6c7a61df434bbd09918d" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.ec9d49ca50e4b80bdb08f0417a28ed84.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header header--fixed">
  
  
  
  
  












<header>
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Yao Xu</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Yao Xu</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>Home</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#skills"><span>Skills</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#accomplishments"><span>Courses</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#experiences"><span>Experience</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#projects"><span>Projects</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        
          
        

        
        
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item dropdown theme-dropdown">
          <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
            <i class="fas fa-moon" aria-hidden="true"></i>
          </a>
          <div class="dropdown-menu">
            <a href="#" class="dropdown-item js-set-theme-light">
              <span>Light</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-dark">
              <span>Dark</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-auto">
              <span>Automatic</span>
            </a>
          </div>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <article class="article">

  













  

  
  
  
<div class="article-container pt-3">
  <h1>RISC-V OS Kernel Rewrite Based on MIT Xv6</h1>

  
  <p class="page-subtitle">Implementation notes of the OS</p>
  

  
    


<div class="article-metadata">

  
  
  
  
  <div>
    

  <span class="author-highlighted">
      Yao (John) Xu</span>
  </div>
  
  

  
  <span class="article-date">
    
    
      
    
    May 2, 2023
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    16 min read
  </span>
  

  
  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/operating-system/">Operating System</a></span>
  

</div>

    





  
</div>



  <div class="article-container">

    <div class="article-style">
      <h1 id="repo-link">Repo Link</h1>
<p><a href="https://github.com/YaoGH-code/OS" target="_blank" rel="noopener">https://github.com/YaoGH-code/OS</a></p>
<h1 id="entrys">entry.S</h1>
<p>As per the specifications mentioned in the linker script, the RAM in the system begins at the physical address 0x80000000. It has a total size of 128 megabytes (128M). The specific memory layout is determined by the way QEMU simulates the memory in the system.</p>
<p>Once the boot loader successfully loads the kernel into the RAM, the execution of the system starts from the entry.S file. This file serves as the entry point of the kernel code.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">.section</span> <span class="no">.text</span>
</span></span><span class="line"><span class="cl"><span class="na">.global</span> <span class="no">_entry</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">_entry:</span>                 <span class="cm">/* basically adding a offset ((mhartid+1)*4096) to 
</span></span></span><span class="line"><span class="cl"><span class="cm">                        find the starting address of each hart */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">la</span> <span class="no">sp</span><span class="p">,</span> <span class="no">stack0</span>       <span class="c1"># load the address of symbol stack0 to sp register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">li</span> <span class="no">a0</span><span class="p">,</span> <span class="mi">4096</span>         <span class="c1"># load the immediate to a0 register
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/*  csrr: Control and Status Register Read
</span></span></span><span class="line"><span class="cl"><span class="cm">    The mhartid CSR is an XLEN-bit read-only register containing the integer 
</span></span></span><span class="line"><span class="cl"><span class="cm">    ID of the hardware thread running the code. This register must be 
</span></span></span><span class="line"><span class="cl"><span class="cm">    readable in any implementation. Hart IDs might not necessarily be 
</span></span></span><span class="line"><span class="cl"><span class="cm">    numbered contiguously in a multiprocessor system, but at least one hart 
</span></span></span><span class="line"><span class="cl"><span class="cm">    must have a hart ID of zero. 
</span></span></span><span class="line"><span class="cl"><span class="cm">    mhartid -&gt; Machine Hart ID -&gt; to identify 
</span></span></span><span class="line"><span class="cl"><span class="cm">    currently running thread Hart -&gt; Hardware Thread */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">csrr</span> <span class="no">a1</span><span class="p">,</span> <span class="no">mhartid</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addi</span> <span class="no">a1</span><span class="p">,</span> <span class="no">a1</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1"># a1 += 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">mul</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">a1</span>      <span class="c1"># a0 *= a1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">add</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="no">a0</span>      <span class="c1"># sp += a0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">call</span> <span class="no">start</span>          <span class="c1"># go to start in start.c
</span></span></span></code></pre></div><p>The purpose of the code snippet is to load the address of an initial stack for each core into the sp (stack pointer) register. This allows for a smooth transition to the C code in the start.c file. In start.c, the stack is defined as an array, and each core can utilize a portion of this array as its stack.</p>
<h1 id="about-plic---platform-level-interrupt-controller">About PLIC - Platform Level Interrupt Controller</h1>
<p>Interrupts are events that occur in computer systems when certain devices or processes require immediate attention from the CPU. These devices can include input devices like keyboards or disks. When an interrupt is generated, it signals the CPU to temporarily pause its current execution and handle the interrupt request.
When an interrupt occurs, a specific bit called the interrupt pending bit associated with the corresponding device is set. All cores that have that particular device enabled are notified, causing a trap or exception to be triggered. This trap transfers control to the interrupt handler, which is responsible for processing the interrupt.
To determine which device caused the interrupt, the trap handler reads a memory-mapped register in the Platform-Level Interrupt Controller (PLIC). This register contains information about the interrupting device, and the handler retrieves the ID associated with that device. Additionally, the PLIC clears the interrupt pending bit for that device.
Each device is assigned a unique device number, and cores can be interrupted in different modes, such as machine, supervisor, or user mode. Moreover, each device is assigned a priority, while each core is allocated a threshold value. Only devices with a priority higher than the core&rsquo;s threshold can generate interrupts and interrupt the core&rsquo;s ongoing operations. This prioritization helps ensure that critical or time-sensitive events take precedence over less important ones.</p>
<p>In the plic_init function, the device priority for the UART and disk is set to 1. This indicates that these devices have a higher priority compared to others in the system. Setting priorities helps determine the order in which interrupts are handled.
In the plic_init_hart function, the interrupt matrix is updated to enable interrupts from the disk and UART devices for a specific core. This means that this particular core is now capable of receiving and processing interrupts from these devices.
Furthermore, the priority threshold for the core is set to 0. This threshold determines which interrupts can interrupt the core&rsquo;s ongoing operations. By setting it to 0, no interrupts are blocked based on their priority. This ensures that all interrupts from enabled devices will be serviced by the core.
The interrupt_claim and interrupt_complete functions are used by a core to claim an interrupt and mark its completion. When an interrupt occurs, the core can use the interrupt_claim function to indicate that it will handle the interrupt. Once the interrupt service routine is completed, the interrupt_complete function is called to notify the PLIC that the interrupt has been serviced and can be cleared.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* Each PLIC interrupt source can be assigned a priority 
</span></span></span><span class="line"><span class="cl"><span class="cm">* by writing to its 32-bit memory-mapped priority 
</span></span></span><span class="line"><span class="cl"><span class="cm">* register. The FU540-C000 supports 7 levels of 
</span></span></span><span class="line"><span class="cl"><span class="cm">* priority. A priority value of 0 is reserved to mean 
</span></span></span><span class="line"><span class="cl"><span class="cm">* &#34;never interrupt&#34; and effectively disables the 
</span></span></span><span class="line"><span class="cl"><span class="cm">* interrupt. Priority 1 is the lowest active priority, 
</span></span></span><span class="line"><span class="cl"><span class="cm">* and priority 7 is the highest. Ties between global 
</span></span></span><span class="line"><span class="cl"><span class="cm">* interrupts of the same priority are broken by the 
</span></span></span><span class="line"><span class="cl"><span class="cm">* Interrupt ID; interrupts with the lowest ID have the 
</span></span></span><span class="line"><span class="cl"><span class="cm">* highest effective priority.
</span></span></span><span class="line"><span class="cl"><span class="cm">* Here, we set the device priority of UART and disk to 1.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">plic_init</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;+------------------------------------------+</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;|               plic_init                  |</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;+------------------------------------------+</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nf">mm_writew</span><span class="p">(</span><span class="n">PLIC_PRIORITY_BASE</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">UART0_IRQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nf">mm_writew</span><span class="p">(</span><span class="n">PLIC_PRIORITY_BASE</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">VIRTIO0_IRQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nf">plic_init_hart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">* Each global interrupt can be enabled by setting the 
</span></span></span><span class="line"><span class="cl"><span class="cm">* corresponding bit in the enables registers. The 
</span></span></span><span class="line"><span class="cl"><span class="cm">* enables registers are accessed as a contiguous 
</span></span></span><span class="line"><span class="cl"><span class="cm">* array of 2 × 32-bit words, packed the same way as 
</span></span></span><span class="line"><span class="cl"><span class="cm">* the pending bits. Bit 0 of enable word 0 represents 
</span></span></span><span class="line"><span class="cl"><span class="cm">* the non-existent interrupt ID 0 and is hardwired to 
</span></span></span><span class="line"><span class="cl"><span class="cm">* 0.
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* The FU540-C000 supports setting of an interrupt 
</span></span></span><span class="line"><span class="cl"><span class="cm">* priority threshold via the threshold register. The 
</span></span></span><span class="line"><span class="cl"><span class="cm">* threshold is a WARL field, where the FU540-C000 
</span></span></span><span class="line"><span class="cl"><span class="cm">* supports a maximum threshold of 7. The FU540-C000 
</span></span></span><span class="line"><span class="cl"><span class="cm">* masks all PLIC interrupts of a priority less than 
</span></span></span><span class="line"><span class="cl"><span class="cm">* or equal to threshold. For example, a threshold 
</span></span></span><span class="line"><span class="cl"><span class="cm">* value of zero permits all interrupts with non-zero 
</span></span></span><span class="line"><span class="cl"><span class="cm">* priority, whereas a value of 7 masks all interrupts.
</span></span></span><span class="line"><span class="cl"><span class="cm">* 
</span></span></span><span class="line"><span class="cl"><span class="cm">* Here, we update the interrupt matrix, enable interrupt 
</span></span></span><span class="line"><span class="cl"><span class="cm">* from disk and UART for a particular core and also set 
</span></span></span><span class="line"><span class="cl"><span class="cm">* priority threshold to 0 so we do not block any 
</span></span></span><span class="line"><span class="cl"><span class="cm">* interrupt.
</span></span></span><span class="line"><span class="cl"><span class="cm">*
</span></span></span><span class="line"><span class="cl"><span class="cm">* Also, no need to care about machine mode.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">plic_init_hart</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="kt">uint64_t</span> <span class="n">hartid</span> <span class="o">=</span> <span class="nf">read_tp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="nf">mm_writew</span><span class="p">(</span><span class="n">PLIC_SEN_BASE</span> <span class="o">+</span> <span class="n">hartid</span> <span class="o">*</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">VIRTIO0_IRQ</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UART0_IRQ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="nf">mm_writew</span><span class="p">(</span><span class="n">PLIC_STHRES_BASE</span> <span class="o">+</span> <span class="n">hartid</span> <span class="o">*</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">trap_claim</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="kt">uint64_t</span> <span class="n">hartid</span> <span class="o">=</span> <span class="nf">read_tp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nf">mm_readw</span><span class="p">(</span><span class="n">PLIC_SCLAIM</span> <span class="o">+</span> <span class="n">hartid</span> <span class="o">*</span> <span class="mh">0x2000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">trap_complete</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="kt">uint64_t</span> <span class="n">hartid</span> <span class="o">=</span> <span class="nf">read_tp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="nf">mm_writew</span><span class="p">(</span><span class="n">PLIC_SCLAIM</span> <span class="o">+</span> <span class="n">hartid</span> <span class="o">*</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="about-uart">About UART</h1>
<p>In the QEMU environment, the UART hardware that the driver communicates with is emulated as a 16550 chip. In a real computer, a 16550 chip would typically manage an RS232 serial link, which connects to a terminal or another computer. However, when running QEMU, the emulated UART is connected to the keyboard and display of the virtual machine.</p>
<p>To interface with the UART hardware, software interacts with a set of memory-mapped control registers. These registers are mapped to specific physical addresses that are connected to the UART device within the RISC-V hardware. In the context of the RISC-V system, the memory-mapped addresses for the UART hardware start at the address 0x10000000. By accessing and manipulating these specific addresses, software can read from and write to the UART control registers, enabling communication with external devices and facilitating tasks such as sending and receiving data through the emulated UART interface.</p>
<p>The initialization process for UART involves three key steps: configuring the baud rate, enabling the internal FIFO queue, and activating the interrupts for receive register full and transmit register empty.</p>
<p>To immediately send a character, we can employ a busy wait approach where we continuously check the transmit register empty bit in the line status register until it becomes unset. Once the bit is unset, we can place the character in the transmit holding register.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* Transmit a char through UART when transmitter hold register is empty by
</span></span></span><span class="line"><span class="cl"><span class="cm">   writing the char to THR register */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">uart_putc_sync</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">intr_push</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nf">mm_readb</span><span class="p">(</span><span class="n">LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LSR_THR_IDLE</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mm_writeb</span><span class="p">(</span><span class="n">THR</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">intr_pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>One common approach to implementing a UART driver is by utilizing a buffer and interrupt mechanism. This involves using interrupts to handle events such as receiving characters from an external source or when the transmit register is empty. When a UART interrupt occurs, the uart_isr function is executed(called from kernel or user level interrupt handler).
Within the uart_isr function, the received character in the receive register is checked. If there is a character present, it will be processed and echoed back. Additionally, if the buffer is not empty, as many characters in the buffer as possible will be sent via the UART.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">uart_isr</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="nf">uart_get_char</span><span class="p">())</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">console_isr</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">uart_flush</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">uart_flush</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">acquire_spinlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nf">mm_readb</span><span class="p">(</span><span class="n">LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LSR_THR_IDLE</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">head</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mm_writeb</span><span class="p">(</span><span class="n">THR</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">release_spinlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Right after initialization, when the Interrupt Status Register (ISR) is set to 1, which indicates the presence of a pending interrupt. Consequently, enabling the global interrupt will immediately generate an interrupt. In the case where the receive register is full, the ISR will be set to generate an interrupt, ensuring that the system responds to the incoming data. Similarly, when the transmit register transitions from a full state to an empty state, the ISR will also be set to trigger an interrupt. This interrupt aims to facilitate the retrieval of additional characters from the ring buffer for transmission.</p>
<h1 id="about-trap">About Trap</h1>
<p>According to the definition and interpretation of traps in xv6, trap includes system call, exception and interrupt. Following is how a RISC-V CPU and xv6 kernel handle a trap.</p>
<p>When a trap occurs the hardware will do the following things:</p>
<ul>
<li>If the SIE in sstatus is cleared which means the interrupt is disabled, the trap remains pending until interrupts are re-enabled.</li>
<li>Disable interrupts by clearing SIE</li>
<li>Copy the pc to sepc to save current pc</li>
<li>Save the current mode (user or supervisor) in the SPP bit in sstatus</li>
<li>Set scause to reflect the trap’s cause</li>
<li>Set the mode to supervisor</li>
<li>Copy stvec to the pc</li>
</ul>
<p><span style="color:orange">After completing the necessary initialization steps, the core begins executing the user trap handler, which consists of assembly code located in the trap page. This trap page is mapped to the virtual address space of all processes. Since hardware aims to maintain simplicity, the address space is not automatically switched by the hardware. Therefore, while executing this assembly code, we are still operating within the address space of the process that triggered the trap and entered the kernel.
<span ></p>
<p><span style="color:orange">By utilizing the sscratch register, we can free up a general-purpose register for accessing the trap frame. The trap frame contains important information about the kernel space, such as the kernel page table root address, stack pointer, and core ID. Initially, it is essential to save all registers from the user space into the trap frame, which is defined as a structure in the proc.h file.
Next, we load the stack pointer, hardware thread ID, and install the kernel page table. It is worth noting that all memory accesses are performed before installing the kernel page table, which is achieved by setting a memory fence. This ensures that necessary address operations are completed using the current address space.
Finally, we jump to the user trap C code, which allows further processing and handling of the trap within the kernel.
<span ></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">globl</span> <span class="no">usertrap</span>
</span></span><span class="line"><span class="cl"><span class="nl">usertrap:</span>    
</span></span><span class="line"><span class="cl">        <span class="nf">csrrw</span> <span class="no">a0</span><span class="p">,</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">a0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/** 
</span></span></span><span class="line"><span class="cl"><span class="cm">         * Each process has a separate trap frame but it&#39;s mapped 
</span></span></span><span class="line"><span class="cl"><span class="cm">         * to the same virtual address
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">li</span> <span class="no">a0</span><span class="p">,</span> <span class="mi">0x3fffffe000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          |   TRAP FRAME   |
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          |   Kernel satp  | OFF: 0
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          |   Kernel sp    | OFF: 8
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          |   User trap    | OFF: 16
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          |      epc       | OFF: 24
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          | Kernel hartid  | OFF: 32
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          |  GP registers  | OFF: 40 - 280
</span></span></span><span class="line"><span class="cl"><span class="cm">          +----------------+
</span></span></span><span class="line"><span class="cl"><span class="cm">          */</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="cm">/* Save user registers in the trap frame
</span></span></span><span class="line"><span class="cl"><span class="cm">         which is defined in proc.h */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">ra</span><span class="p">,</span>  <span class="mi">40</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">sp</span><span class="p">,</span>  <span class="mi">48</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">gp</span><span class="p">,</span>  <span class="mi">56</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">tp</span><span class="p">,</span>  <span class="mi">64</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="na">......</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">t4</span><span class="p">,</span>  <span class="mi">264</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">t5</span><span class="p">,</span>  <span class="mi">272</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">t6</span><span class="p">,</span>  <span class="mi">280</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Save a0 from the user space to t0 since t0
</span></span></span><span class="line"><span class="cl"><span class="cm">           has been save to the trap frame */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">csrr</span> <span class="no">t0</span><span class="p">,</span> <span class="no">sscratch</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Save t0 (a0) to the trap frame to finish saving 
</span></span></span><span class="line"><span class="cl"><span class="cm">           all of the user registers */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sd</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">112</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Initialize kernel stack pointer, remember each process 
</span></span></span><span class="line"><span class="cl"><span class="cm">        has a kernel stack, the proc-&gt;kstack contains the 
</span></span></span><span class="line"><span class="cl"><span class="cm">        virtual address of the kernel stack */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ld</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Load the address of usertrap(), this should be set before 
</span></span></span><span class="line"><span class="cl"><span class="cm">        returning to user mode */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ld</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">ld</span> <span class="no">tp</span><span class="p">,</span> <span class="mi">32</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Wait for any previous memory operations to complete 
</span></span></span><span class="line"><span class="cl"><span class="cm">        which uses the user page table */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sfence.vma</span> <span class="no">zero</span><span class="p">,</span> <span class="no">zero</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Install the kernel page table */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ld</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">csrw</span> <span class="no">satp</span><span class="p">,</span> <span class="no">t1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Flush now-stale user entries from the TLB */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sfence.vma</span> <span class="no">zero</span><span class="p">,</span> <span class="no">zero</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Jump to usertrap(), which does not return */</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* NOTICE all memory access to the trap frame is done before switching 
</span></span></span><span class="line"><span class="cl"><span class="cm">           the page table */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">jr</span> <span class="no">t0</span>
</span></span></code></pre></div><p>Trap handing that happens in the kernel is simpiler. By setting the STEVC register to the assembly symbol &ldquo;ktrap&rdquo;, the trap handling process in the kernel, executed in supervisor mode. The assembly code portion of the kernel trap handler primarily focuses on saving all general-purpose registers before passing control to the C kernel trap handler. After the C kernel trap handler completes its execution, the previously saved registers are restored. This simplified approach allows for efficient and streamlined trap handling within the kernel.</p>
<p>The rewritten C part of the trap handling code is the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">kernel_trap</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">cause</span> <span class="o">=</span> <span class="nf">read_scause</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">exp_code</span> <span class="o">=</span> <span class="nf">GET_EXP_CODE</span><span class="p">(</span><span class="n">cause</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">IS_INTERRUPT</span><span class="p">(</span><span class="n">cause</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">exp_code</span> <span class="o">==</span> <span class="n">CAUSE_EXTI</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="nf">trap_claim</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">UART0_IRQ</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">uart_isr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">VIRTIO0_IRQ</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">disk_isr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;unexpected interrupt irq=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nf">trap_complete</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">exp_code</span> <span class="o">==</span> <span class="n">CAUSE_SOFT</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="nf">get_coreid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">clock_isr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nf">write_sip</span><span class="p">(</span><span class="nf">read_sip</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="nf">get_myproc</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">get_myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">RUNNING</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// yield();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The scause register provides crucial information regarding a trap. If the trap is not an interrupt, it is caused by a system call. However, if it is an interrupt, we can examine the exception code to determine the source of the interrupt by querying the PLIC. The interrupt could be triggered by devices such as UART or disk. One specific core should handle and process this trap.</p>
<h1 id="vmc">vm.c</h1>
<p>The function kernel_vm_init() is responsible for creating page tables that define the mapping of the kernel&rsquo;s address space. During this process, specific sections such as UART, Text, Data, PLIC, Virtio, and Trap are mapped to their corresponding virtual addresses. It&rsquo;s important to note that all sections, except for Trap, are directly mapped to their respective virtual addresses. However, Trap is unique in that it is mapped to the highest page within the virtual address space. Following is virtual address space of the Xv6 kernel:</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="Image alt" srcset="
               /post/os/kvm_map_hu1323a63b9b8de467c3809f82f9e2e3e1_66252_ef2029b9fd6f13042d6c158ceb8653d5.webp 400w,
               /post/os/kvm_map_hu1323a63b9b8de467c3809f82f9e2e3e1_66252_068b468d05ec8b4d30a3856bb8a6cd90.webp 760w,
               /post/os/kvm_map_hu1323a63b9b8de467c3809f82f9e2e3e1_66252_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/post/os/kvm_map_hu1323a63b9b8de467c3809f82f9e2e3e1_66252_ef2029b9fd6f13042d6c158ceb8653d5.webp"
               width="637"
               height="649"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>The function map_pages() is designed to map a range of virtual addresses to corresponding physical addresses. It takes parameters: the virtual address, the size of the memory region to be mapped, and the physical address where the mapping should be established.
To begin, map_pages() calculates the starting and ending addresses of the virtual address range that needs to be mapped. Using a while loop, map_pages() iteratively calls the function search_pt_tree() to map one page at a time.</p>
<p>The function search_pt_tree() iterates through each level of the page table by extracting the page table index for each level. Using this index, it retrieves the corresponding physical address from the Page Table Entry (PTE). If the valid bit in the PTE is set, it indicates that we can directly proceed to the next level of the page table. If the valid bit is not set, it means that a physical page needs to be allocated for the next level of the page table. In the end, the function returns the address of the lowest level of the Page Table Entry (PTE).</p>
<p>Function unmap_pages() does the opposite thing of map_pages(). It will goes through all levels of page table based on the virtual address and set the lowest level of PTE to 0 and free the coressponding physical data page by calling kfree().</p>
<p>The unmap_pages() function performs the inverse operation of the map_pages() function. It traverses through all levels of the page table hierarchy based on the virtual address provided. The purpose of unmap_pages() is to invalidate the mapping between a virtual address and its corresponding physical data page.
To achieve this, unmap_pages() sets the value of the lowest-level Page Table Entry (PTE) to 0. The PTE is responsible for storing the mapping information between a virtual page and its corresponding physical page. By setting it to 0, the mapping is removed.
Additionally, unmap_pages() calls the kfree() function to free the corresponding physical data page.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Xv6 runs on Sv39 RISC-V, which means that only the bottom 39 bits of a 64-bit virtual 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * address are used; the top 25 bits are not used.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The risc-v Sv39 scheme uses three levels of page-table pages. A page-table page 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * contains 512 64-bit PTEs.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Each PTE contains a 44-bit physical page number (PPN) and some flags.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The paging hardware translates a virtual address by using the top 27 bits of the 39 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * bits to index into the page table to find a PTE, and making a 56-bit physical address
</span></span></span><span class="line"><span class="cl"><span class="cm"> * whose top 44 bits come from the PPN in the PTE and whose bottom 12 bits are copied 
</span></span></span><span class="line"><span class="cl"><span class="cm"> * from the original virtual address. 
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Virtual Address Structure:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * +-------------+---------------+---------------+---------------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="cm"> * |     25      |       9       |       9       |       9       |          12         |
</span></span></span><span class="line"><span class="cl"><span class="cm"> * +-------------+---------------+---------------+---------------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="cm"> * |    39-63    |     30-38     |     21-29     |     12-20     |         0-11        |
</span></span></span><span class="line"><span class="cl"><span class="cm"> * +-------------+---------------+---------------+---------------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="cm"> * |  Must be 0  | Level-2 Index | Level-1 Index | Level-0 Index | Byte Offset in Page |
</span></span></span><span class="line"><span class="cl"><span class="cm"> * +-------------+---------------+---------------+---------------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>   
</span></span><span class="line"><span class="cl"><span class="cm">/* Return the address of the PTE in page table pagetable that corresponds 
</span></span></span><span class="line"><span class="cl"><span class="cm">to virtual address va. Create any required page-table pages if needed. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">pte_t</span><span class="o">*</span> <span class="nf">search_pt_tree</span><span class="p">(</span><span class="kt">ptb_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">va</span> <span class="o">&gt;</span> <span class="n">MAXVA</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">kerror</span><span class="p">(</span><span class="n">__FILE_NAME__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="s">&#34;Illegal virtual memory address&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Get the index for the current level of page table */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint64_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">GET_PT_IDX</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/* Get PTE from page table */</span>
</span></span><span class="line"><span class="cl">        <span class="kt">pte_t</span><span class="o">*</span> <span class="n">pte</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">PTE_VALID</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* If this PTE is valid, then we get PA from this PTE and
</span></span></span><span class="line"><span class="cl"><span class="cm">               may going into the next level of page table using this 
</span></span></span><span class="line"><span class="cl"><span class="cm">               PA */</span>
</span></span><span class="line"><span class="cl">            <span class="n">pagetable</span> <span class="o">=</span> <span class="p">(</span><span class="kt">ptb_t</span><span class="p">)</span><span class="nf">GET_PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/* If it is not valid (not initialized), then allocate 
</span></span></span><span class="line"><span class="cl"><span class="cm">               and initialize the corresponding page table, return 
</span></span></span><span class="line"><span class="cl"><span class="cm">               0 */</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">alloc</span> <span class="o">||</span> <span class="p">(</span><span class="n">pagetable</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="nf">kmalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// printk(&#34;[vm.c] allocated page %p for level %d page table\n&#34;,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// pagetable, level-1);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">memset</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nf">GET_PTE</span><span class="p">(</span><span class="n">pagetable</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="nf">GET_PT_IDX</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">map_pages</span><span class="p">(</span><span class="kt">ptb_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">va</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="n">purp</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">kerror</span><span class="p">(</span><span class="n">__FILE_NAME__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="s">&#34;Incorrect size&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">curr_va</span> <span class="o">=</span> <span class="nf">ADDR_ROUND</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">end_va</span>  <span class="o">=</span> <span class="nf">ADDR_ROUND</span><span class="p">((</span><span class="n">va</span><span class="o">+</span><span class="n">size</span><span class="p">),</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;[vm.c] Mapping va[%p-%p] to pa[%p] for %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">curr_va</span><span class="p">,</span> <span class="n">end_va</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">purp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pte_t</span><span class="o">*</span> <span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">curr_va</span> <span class="o">&lt;</span> <span class="n">end_va</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pte</span> <span class="o">=</span> <span class="nf">search_pt_tree</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">curr_va</span><span class="p">,</span> <span class="n">PG_ALLOC</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">PTE_VALID</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">            <span class="nf">kerror</span><span class="p">(</span><span class="n">__FILE_NAME__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="s">&#34;PTE already valid&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="nf">GET_PTE</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr_va</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pa</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">unmap_pages</span><span class="p">(</span><span class="kt">ptb_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">va</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">kerror</span><span class="p">(</span><span class="n">__FILE_NAME__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="s">&#34;Incorrect size&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">curr_va</span> <span class="o">=</span> <span class="nf">ADDR_ROUND</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">end_va</span>  <span class="o">=</span> <span class="nf">ADDR_ROUND</span><span class="p">((</span><span class="n">va</span><span class="o">+</span><span class="n">size</span><span class="p">),</span> <span class="n">PSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;[vm.c] Unmapping va[%p-%p]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">curr_va</span><span class="p">,</span> <span class="n">end_va</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pte_t</span><span class="o">*</span> <span class="n">pte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">curr_va</span> <span class="o">&lt;</span> <span class="n">end_va</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="nf">search_pt_tree</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">curr_va</span><span class="p">,</span> <span class="n">PG_NOT_ALLOC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="nf">kerror</span><span class="p">(</span><span class="n">__FILE_NAME__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="s">&#34;search_pt_tree error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span><span class="p">)</span> <span class="o">==</span> <span class="n">PTE_V</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="nf">kerror</span><span class="p">(</span><span class="n">__FILE_NAME__</span><span class="p">,</span><span class="n">__LINE__</span><span class="p">,</span><span class="s">&#34;unmap page valid error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printk</span><span class="p">(</span><span class="s">&#34;kfree: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nf">GET_PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="nf">GET_PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr_va</span> <span class="o">+=</span> <span class="n">PSIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="procc">proc.c</h1>

    </div>

    





<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/academic/">Academic</a>
  
  <a class="badge badge-light" href="/tag/open-source/">Open Source</a>
  
</div>



<div class="share-box">
  <ul class="share">
    
      
      
      
        
      
      
      
      
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=http%3A%2F%2Fyaogh-code.github.io%2Fpost%2Fos%2F&amp;text=RISC-V&#43;OS&#43;Kernel&#43;Rewrite&#43;Based&#43;on&#43;MIT&#43;Xv6" target="_blank" rel="noopener" class="share-btn-twitter" aria-label="twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=http%3A%2F%2Fyaogh-code.github.io%2Fpost%2Fos%2F&amp;t=RISC-V&#43;OS&#43;Kernel&#43;Rewrite&#43;Based&#43;on&#43;MIT&#43;Xv6" target="_blank" rel="noopener" class="share-btn-facebook" aria-label="facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      
      
      
      
        
      
      <li>
        <a href="mailto:?subject=RISC-V%20OS%20Kernel%20Rewrite%20Based%20on%20MIT%20Xv6&amp;body=http%3A%2F%2Fyaogh-code.github.io%2Fpost%2Fos%2F" target="_blank" rel="noopener" class="share-btn-email" aria-label="envelope">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=http%3A%2F%2Fyaogh-code.github.io%2Fpost%2Fos%2F&amp;title=RISC-V&#43;OS&#43;Kernel&#43;Rewrite&#43;Based&#43;on&#43;MIT&#43;Xv6" target="_blank" rel="noopener" class="share-btn-linkedin" aria-label="linkedin-in">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      
      
      
      
      <li>
        <a href="whatsapp://send?text=RISC-V&#43;OS&#43;Kernel&#43;Rewrite&#43;Based&#43;on&#43;MIT&#43;Xv6%20http%3A%2F%2Fyaogh-code.github.io%2Fpost%2Fos%2F" target="_blank" rel="noopener" class="share-btn-whatsapp" aria-label="whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=http%3A%2F%2Fyaogh-code.github.io%2Fpost%2Fos%2F&amp;title=RISC-V&#43;OS&#43;Kernel&#43;Rewrite&#43;Based&#43;on&#43;MIT&#43;Xv6" target="_blank" rel="noopener" class="share-btn-weibo" aria-label="weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>











  
  
    



  
  
  
    
  
  
  
  <div class="media author-card content-widget-hr">
    
      
      <a href="http://yaogh-code.github.io/"><img class="avatar mr-3 avatar-circle" src="/authors/admin/avatar_hu59ef75cf9b43e629b03a2eb6d5690fa5_817895_270x270_fill_q75_lanczos_center.jpg" alt="Yao (John) Xu"></a>
    

    <div class="media-body">
      <h5 class="card-title"><a href="http://yaogh-code.github.io/">Yao (John) Xu</a></h5>
      <h6 class="card-subtitle">Graduate student at Carnegie Mellon University</h6>
      
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
    <li>
      <a href="mailto:johnx9566@gmail.com" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/YaoGH-code" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.linkedin.com/in/johnnyyxu" target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
    </li>
  
    
    
    
    
    
    
    
      
    
    <li>
      <a href="/uploads/resume1.pdf" >
        <i class="ai ai-cv"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>


  
















  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  












  
  
  
  
  













  
  
  

  
  
    
  
  
    
  

  

  
  <p class="powered-by copyright-license-text">
    © {2023} Yao Xu
  </p>
  

  <p class="powered-by footer-license-icons">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank" aria-label="Creative Commons">
      <i class="fab fa-creative-commons fa-2x" aria-hidden="true"></i>
      <i class="fab fa-creative-commons-by fa-2x" aria-hidden="true"></i>
      
        <i class="fab fa-creative-commons-nc fa-2x" aria-hidden="true"></i>
      
      
        <i class="fab fa-creative-commons-nd fa-2x" aria-hidden="true"></i>
      
    </a>
  </p>





  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      Published with <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a> — the free, <a href="https://github.com/wowchemy/wowchemy-hugo-themes" target="_blank" rel="noopener">open source</a> website builder that empowers creators.
    
  </p>
</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.d26509351aa0ff874abbee824e982e9b.js"></script>




  

  
  

  













  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":true}</script>



  <script src="/js/wowchemy-headroom.db4755770454eb63685f8de785c0a172.js" type="module"></script>









  
  


<script src="/en/js/wowchemy.min.e8ee06ba8371980ffde659871dd593b0.js"></script>







  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        
        <pre><code></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>


  <script src="/js/wowchemy-publication.68f8d7090562ca65fc6d3cb3f8f2d2cb.js" type="module"></script>


















</body>
</html>
