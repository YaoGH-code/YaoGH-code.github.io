<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learning notes | Yao Xu</title>
    <link>http://yaogh-code.github.io/tag/learning-notes/</link>
      <atom:link href="http://yaogh-code.github.io/tag/learning-notes/index.xml" rel="self" type="application/rss+xml" />
    <description>Learning notes</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 30 Apr 2023 10:00:00 +0000</lastBuildDate>
    <image>
      <url>http://yaogh-code.github.io/media/icon_hu3fa31baf23334842a6c8f8d4ce717078_16335_512x512_fill_lanczos_center_3.png</url>
      <title>Learning notes</title>
      <link>http://yaogh-code.github.io/tag/learning-notes/</link>
    </image>
    
    <item>
      <title>Data Structures and Algorithms (C&#43;&#43;)</title>
      <link>http://yaogh-code.github.io/post/leetcode/</link>
      <pubDate>Sun, 30 Apr 2023 10:00:00 +0000</pubDate>
      <guid>http://yaogh-code.github.io/post/leetcode/</guid>
      <description>&lt;!-- ```python
import libr
print(&#39;hello&#39;)
``` --&gt;
&lt;!-- 
## 1. Two Sum
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.
```C++
/* 
Solution: Loop through all elements in the nums array. 
If the number we want is in the hash map, then we return 
the val(index) of the key(target-nums[i]) and the current 
index. Otherwise, we add that key-val into the hash map. 
Finally, there is no such number in the array, return 
empty array. 
*/
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int,int&gt; M;
        for(int i=0; i&lt;nums.size(); i++){
            if (M.count(target-nums[i])) 
                return {i, M[target-nums[i]]};
            else M[nums[i]] = i;
        }
        return {};
    }
};
```

## 2. Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.
ex:&amp;nbsp;
2-&gt;4-&gt;3
&amp;nbsp;
5-&gt;6-&gt;4
&amp;nbsp;
7-&gt;0-&gt;8
&amp;nbsp;
```C++
/*
Solution: We have two linked lists for two numbers. We loop through 
two linked lists in the while loop and compute a temp sum for each 
digit (also include the carry) and add new node which representing a
digit in the new number to the output linked list. Also, updates the 
carry for the next iteration.
*/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy_head = new ListNode(-1);
        ListNode* current = dummy_head;
        int carry=0;
        while(l1 || l2 || carry){
            int sum=0;
            if(l1){
                sum += l1-&gt;val;
                l1 = l1-&gt;next;
            }
            if(l2){
                sum += l2-&gt;val;
                l2 = l2-&gt;next;
            }
            sum += carry;
            ListNode* node = new ListNode(sum%10);
            carry = sum/10;
            current-&gt;next = node;
            current = current-&gt;next;
        }
        return dummy_head-&gt;next;
    }
};
```

## 3. Longest Substring Without Repeating Characters
Given a string s, find the length of the longest substring without repeating characters.
```C++
/*
Solution: The key point is to correctly kepp track of the left pointer.
If we do not use max(left, M[s[i]]+1), we might cover a string with 
repeated char that we have identiftied before (ex. abba) which is wrong 
so we cannot let left pointer goes backward to cover substring with 
potential repeated char.
*/
//we cannot move the left back
//abba
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (!s.size()) return 0;
        unordered_map&lt;char, int&gt; m;
        int max_len = 1;
        int left = 0;
        for (int i=0; i&lt;s.length(); i++){
            if (m.count(s[i])){
                left = max(left, m[s[i]]+1);
            }
            m[s[i]] = i;
            max_len = max(max_len, i-left+1);
        }
        return max_len;
    }
};
```


## 5. Longest Palindromic Substring
Given a string s, return the longest palindromic substring in s.
```C++
/*
Solution: helper function: expand from a &#34;pivot&#34; to both sides and try
to find the longest palindromic substring.
There are two cases: substring with odd number of chars and substring
with even number of chars. If the new substring is longer, update the 
starting point and length.
*/
class Solution {
public:
    int helper(int l, int r, string s){
        while(l&gt;=0 &amp;&amp; r&lt;s.length() &amp;&amp; s[l]==s[r]){
            l--;
            r++;
        }
        return r-l-1;
    }
    
    string longestPalindrome(string s) {
        int n=s.length();
        int len=0;
        int start=0;
        for (int i=0; i&lt;n; i++){
            int cur = max(helper(i,i,s), helper(i,i+1,s));
            if (cur&gt;len){
                len=cur;
                start = i-(len-1)/2;
            }
        }
        return s.substr(start,len); 
    }
};
```

## 6. Zigzag Conversion
The string &#34;PAYPALISHIRING&#34; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: &#34;PAHNAPLSIIGYIR&#34;
```C++
/*
Solution: Prepare n strings and fill them with different levels. For example, level 0,1,2...
if we reached the lowest or highest level, change the direction. Finally, put all level of 
strings together.
*/
class Solution {
public:
    string convert(string s, int n) {
        if(n==1) return s;
        vector&lt;string&gt; v(n);
        int level = 0;
        int dir = 1;
        string res;

        for (int i=0; i&lt;s.length(); i++){
            v[level]+=s[i];

            if (dir) level++;
            else level--;

            if (level == n-1) dir=0;
            if (level == 0) dir=1;
        }
        for (string s:v) res+=s;
        return res;
    }
};
```

## 7. Reverse Integer
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
```C++
class Solution {
public:
    int reverse(int x) {
        long long res = 0;
        while(x) {
            res = res*10 + x%10;
            x /= 10;
        }
        return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res;
    }
};
```

## 9. Palindrome Number
Given an integer x, return true if x is a palindrome, and false otherwise.
```C++
class Solution {
public:
    bool isPalindrome(int x) {
        if( x&lt;0 || ( x % 10==0 &amp;&amp; x!=0))
            return false;
        int revno = 0;
        while(x&gt;revno){ // when x&lt;revno we processed half of digits, so we stop
            revno=revno*10 + x%10;
            x=x/10;
        }
        return x==revno || x==revno/10; //1221 or 12321
    }
};
```




## 11. Container With Most Water
```C++
//Author: Yao Xu
/*
We use two pointers to calculate the area with the smaller height.
Then if we reduce or increase the pointer with the smaller value 
and keep track the max value of water.
*/

class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int l=0; 
        int r=height.size()-1;
        int res=0;
        while(l&lt;r){
            res = max(res, min(height[l], height[r])*(r-l));
            if (height[l]&lt;height[r]) l++;
            else r--;
        }
        return res;
    }
};
```

## 12. Integer to Roman
```C++
//Author: Yao Xu
/*
The idea here is to loop through the vector reversely. 
For each element in the vector, if the num we have is 
larger than its value the we subtract that value from 
the input until the num is smaller than the current 
element in the vector.
*/
class Solution {
public:
    string intToRoman(int num) {
            vector&lt;pair&lt;string,int&gt;&gt; v;
            v.push_back(make_pair(&#34;I&#34;,1));
            v.push_back(make_pair(&#34;IV&#34;,4));
            v.push_back(make_pair(&#34;V&#34;,5));
            v.push_back(make_pair(&#34;IX&#34;,9));
            v.push_back(make_pair(&#34;X&#34;,10));
            v.push_back(make_pair(&#34;XL&#34;,40));
            v.push_back(make_pair(&#34;L&#34;,50));
            v.push_back(make_pair(&#34;XC&#34;,90));
            v.push_back(make_pair(&#34;C&#34;,100));
            v.push_back(make_pair(&#34;CD&#34;,400));
            v.push_back(make_pair(&#34;D&#34;,500));
            v.push_back(make_pair(&#34;CM&#34;,900));
            v.push_back(make_pair(&#34;M&#34;,1000));

            string ans=&#34;&#34;;
            for(int i=v.size()-1; i&gt;=0; i--){
                while(num &gt;= v[i].second){
                    num-=v[i].second;
                    ans += v[i].first;
                }
            }
            return ans;
        }
};
```

## 13. Roman to Integer
```C++
// Author: Yao Xu
/*
The idea is we loop through every char in the string 
and add that value to our final result but we have 
to check if the current is larger than the old one, 
if the old one is smaller than the current one we 
have to subtract twice of the old value since we 
have added that value to the result.
*/
class Solution {
public:
    int romanToInt(string s) {
        map&lt;char, int&gt; nums = {{&#39;M&#39;, 1000}, {&#39;D&#39;, 500}, {&#39;C&#39;, 100}, {&#39;L&#39;, 50}, {&#39;X&#39;, 10}, {&#39;V&#39;, 5}, {&#39;I&#39;, 1}};
        int res=0;
        int prev=0;
        for (char c:s){
            int cur = nums[c];
            res += cur;
            if (prev&lt;cur) res -= 2* prev;
            prev = cur;
        }
        return res;
    }
};
```

## 14. Longest Common Prefix
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &#34;&#34;.
Example 1:
Input: strs = [&#34;flower&#34;,&#34;flow&#34;,&#34;flight&#34;]
Output: &#34;fl&#34;
Example 2:
Input: strs = [&#34;dog&#34;,&#34;racecar&#34;,&#34;car&#34;]
Output: &#34;&#34;
Explanation: There is no common prefix among the input strings.
```C++
// Author: Yao Xu
/*
The idea here is to use the first string as a standard and loop through all other strings to check 
the longest prefix. And update the shortest prefix every time when we check a string.
Finally, according to the length we can return the result prefix.
*/
class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        int ref = strs[0].length();
        for (int i=1; i&lt;strs.size(); i++){
            int temp=0;
            while(temp&lt;strs[0].length() &amp;&amp; temp&lt;strs[i].length() &amp;&amp; strs[i][temp] == strs[0][temp]){
                temp++;
            }
            ref = min(ref, temp);
        }
        return strs[0].substr(0,ref);
    }
};
```




## 15. 3Sum
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
```C++
//Author: Yao Xu
/* The idea is to sort the array first. Then, loop through the array with variable i.
if((i &gt; 0) &amp;&amp; nums[i]==nums[i-1]) continue; if current nums[i] and nums[i-1] we skip, 
this is for avoiding duplicates. This is the first way to avoid duplicates.

Then in the interval l-r, we check each possible sum. If the sum is 0, we add that to the
final answer and do the avoding duplicates again by scanning the number in the interval.
Then increment left and decrement right for the next iteratoraiton in the interval.
*/
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        if (!&amp;nums || nums.size()&lt;3) return {};
        vector&lt;vector&lt;int&gt;&gt; res;

        int i=0;
        int left = 1;
        int right = nums.size()-1;
        sort(nums.begin(), nums.end());

        for (int i=0; i&lt;nums.size(); i++){
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;
            left = i+1;
            right = nums.size()-1;
            while(left&lt;right){
                int temp_sum = nums[left] + nums[right] + nums[i];
                if (temp_sum&lt;0) left++;
                else if (temp_sum&gt;0) right--;
                else { 
                    res.push_back({nums[left], nums[right], nums[i]});
                    while(left&lt;right &amp;&amp; nums[left] == nums[left+1]) left++;
                    while(left&lt;right &amp;&amp; nums[right] == nums[right-1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return res;
    }
};
```


## 19. Remove Nth Node From End of List
Given the head of a linked list, remove the nth node from the end of the list and return its head.
```C++
// Author: Yao Xu
/*
The idea is to go to the nth element from the head with the first pointer
then using the second pointer to go through the linked list until the first
pointer points to NULL.
Now, the second points to the position we want, delete that node.
return dummy.next
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode* fast = dummy;
        ListNode* slow = dummy;

        for (int i=0; i&lt;n; i++){
            fast = fast-&gt;next;
        }
        while(fast-&gt;next){
           fast = fast-&gt;next;
           slow = slow-&gt;next; 
        }
        slow-&gt;next = slow-&gt;next-&gt;next;
        return dummy-&gt;next;
    }
};
```

## 20. Valid Parentheses
Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

```C++
// Author: Yao Xu
/*
We are using stack to store the right half. We push the right half hwen we 
find there is a left half. If we find the right half,we check the stack to see if there
is a match or not. We may find there is a right half but the stack is empty, this means the
right half should not be there.
if the right do not matches the left half, this is wrong.
OR if at the end the stack is not empty, then this is also wrong.
*/

class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; stack;
         
        for (int i=0; i&lt;s.length(); i++){
            if (s[i] == &#39;(&#39;) stack.push(&#39;)&#39;);
            else if (s[i] == &#39;{&#39;) stack.push(&#39;}&#39;);
            else if (s[i] == &#39;[&#39;) stack.push(&#39;]&#39;);

            else{
                if (stack.empty()) return false;
                char top = stack.top();
                stack.pop();
                if (top != s[i]) return false;
            }
        }
        if (!stack.empty()) return false;
        return true;
        
    }
};
```

## 21. Merge Two Sorted Lists
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* head = new ListNode(-1);
        ListNode* p = head;
        while(list1 &amp;&amp; list2){
            if (list1-&gt;val &gt; list2-&gt;val){
                p-&gt;next = list2;
                list2=list2-&gt;next;
                p=p-&gt;next;
            }else{
                p-&gt;next = list1;
                list1=list1-&gt;next;
                p=p-&gt;next; 
            }
        }  
        if(list1) p-&gt;next = list1;
        if(list2) p-&gt;next = list2;
        return head-&gt;next;
    }
};
```


## 22. Generate Parenthese
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Example 1:
Input: n = 3
Output: [&#34;((()))&#34;,&#34;(()())&#34;,&#34;(())()&#34;,&#34;()(())&#34;,&#34;()()()&#34;]

Example 2:
Input: n = 1
Output: [&#34;()&#34;]
```C++
// Author: Yao Xu
// Using recursion to solve this problem
/*
Using the idea of adding left side of the parentheses first and then
the right side.
We can add left first if left is not zero since we cannot add right side anyway
if right is less than left means we havn&#39;t finished so we just add right side.
if left == right means we finished one instance so we record the result and push back that
to the vector.
*/
class Solution {
public:
    vector&lt;string&gt; V;
    void helper(string current, int left, int right){
        if (left==0 &amp;&amp; right ==0){
            V.push_back(current);
            return;
        }
        if (left&gt;0){
            helper(current+&#34;(&#34;,left-1,right);
        }
        if (right&gt;left){
            helper(current+&#34;)&#34;,left,right-1);
        }
    }
    vector&lt;string&gt; generateParenthesis(int n) {
        helper(&#34;&#34;,n,n);
        return V;
    }
};
```

## 24. Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)
```C++
/**
 Solution: First make sure there are two more nodes after the 
 current node and swap those two nodes. Make sure store info about 
the first node and the next node of the second node.
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL || head-&gt;next == NULL) 
        return head;

        ListNode* dummy = new ListNode(0);
        dummy-&gt;next = head;
        ListNode* current = dummy;

        while(current-&gt;next &amp;&amp; current-&gt;next-&gt;next){
            ListNode* first = current-&gt;next;

            current-&gt;next = first-&gt;next;
            ListNode* sec_next = first-&gt;next-&gt;next;
            current-&gt;next-&gt;next = first;
            current-&gt;next-&gt;next-&gt;next = sec_next;
            current=current-&gt;next-&gt;next;
        }
        return dummy-&gt;next;
        
    }
};
```

## 26. Remove Duplicates from Sorted Array
```C++
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int slow = 0;
        int fast = 0;
        while (fast &lt; nums.size()){
            if (nums[slow] == nums[fast]){
                fast++;
            } else {
                slow++;
                nums[slow] = nums[fast];
                fast++;
            }
        }
        return slow+1;
    }
};
```

## 27. Remove Element
```C++
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int p=0;
        for (auto i:nums){
            if (i != val){
                nums[p] = i;
                p++;
            }
        }
        return p; 
    }
};
```

## 28. Find the Index of the First Occurrence in a String
```C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        for (int i=0; i&lt;haystack.size(); i++){
            if ( needle.length()&lt;=haystack.size()-i &amp;&amp; haystack.substr(i, needle.length())==needle ){
                return i;
            }
        }
        return -1;
    }
};
```


## 94. Binary Tree Inorder Traversal
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    public:  
    vector&lt;int&gt; res;
    void inorderhelp(TreeNode* root){
        if(root == NULL) return;
        inorderhelp(root-&gt;left);
        res.push_back(root-&gt;val);
        inorderhelp(root-&gt;right);
    }  
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        inorderhelp(root);
        return res;
    }
};
```

## 144. Binary Tree Preorder Traversal
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; vec;
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        if (!root) return {};
        vec.push_back(root-&gt;val);
        preorderTraversal(root-&gt;left);
        
        preorderTraversal(root-&gt;right);
        return vec;
        
    }
};
```

## 145. Binary Tree Postorder Traversal
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; T;
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        if (!root) return {};
        postorderTraversal(root-&gt;left);
        postorderTraversal(root-&gt;right);
        T.push_back(root-&gt;val);
        return T;
    }
};
```


 --&gt;
</description>
    </item>
    
    <item>
      <title>About Make</title>
      <link>http://yaogh-code.github.io/post/makefile/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      <guid>http://yaogh-code.github.io/post/makefile/</guid>
      <description>&lt;!-- ```python
import libr
print(&#39;hello&#39;)
``` --&gt;
&lt;h2 id=&#34;1-introduction&#34;&gt;1. Introduction&lt;/h2&gt;
&lt;p&gt;The make utility automatically determines which pieces of a large program need to be recompiled, and issues commands to recompile them. You need a file called a makefile to tell make what to do. Most often, the makefile tells make how to compile and link a program.&lt;/p&gt;
&lt;h3 id=&#34;syntax&#34;&gt;Syntax&lt;/h3&gt;
&lt;p&gt;A Makefile contains some rules with the following shape:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;target … &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prerequisites&lt;/span&gt; …
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        recipe
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        …
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        …
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’.&lt;/li&gt;
&lt;li&gt;The prerequisites are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called dependencies.&lt;/li&gt;
&lt;li&gt;The commands are a series of steps typically used to make the target(s). These need to &lt;span style=&#34;color:orange&#34;&gt;start with a tab character, not spaces.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is a typical Makefile - one that compiles a single C file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cc test.c -o &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can simply running make. Since there&amp;rsquo;s no target supplied as an argument to the make command, the first target is run. In this case, there&amp;rsquo;s only one target (test). The first time you run this, test will be created. The second time, you&amp;rsquo;ll see make: &amp;rsquo;test&amp;rsquo; is up to date. That&amp;rsquo;s because the test file already exists. &lt;span style=&#34;color:orange&#34;&gt;But there&amp;rsquo;s a problem: if we modify test.c and then run make, nothing gets recompiled.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Instead, we can do this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	cc test.c -o &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When we run make again, the following set of steps happens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first target is selected, because the first target is the default target&lt;/li&gt;
&lt;li&gt;This has a prerequisite of test.c&lt;/li&gt;
&lt;li&gt;Make decides if it should run the test target. It will only run if &lt;span style=&#34;color:orange&#34;&gt;test doesn&amp;rsquo;t exist, or test.c is newer than test.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is a more complicated example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;edit &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kbd&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;display&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;search&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;files&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;utils&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -o edit main.o kbd.o command.o display.o &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;                   insert.o search.o files.o utils.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;main.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c main.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;kbd.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kbd&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c kbd.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;command.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c command.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;display.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;display&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c display.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;insert.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c insert.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;search.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;search&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c search.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;files.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;files&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c files.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;utils.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;utils&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c utils.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;clean &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rm edit main.o kbd.o command.o display.o &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;           insert.o search.o files.o utils.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Edit is a target that requires eight prerequisites. The command is to compile executable file &amp;ldquo;edit&amp;rdquo; with eight object files. Each of the object file requires some C files and header files. We do not need to include header file name in the command since it is already included in the C file and the purpose to include header files in the prerequisites is to make sure the file is already there, just like a additional verification.&lt;/p&gt;
&lt;p&gt;When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first. In this example, edit depends on each of the eight object files; the object file main.o depends on the source file main.c and on the header file defs.h.&lt;/p&gt;
&lt;h3 id=&#34;make-clean&#34;&gt;Make clean&lt;/h3&gt;
&lt;p&gt;The target ‘clean’ is not a file, but merely the name of an action. Since you normally do not want to carry out the actions in this rule, ‘clean’ is not a prerequisite of any other rule. Consequently, make never does anything with it unless you tell it specifically. Note that this rule not only is not a prerequisite, it also does not have any prerequisites, so the only purpose of the rule is to run the specified recipe. Targets that do not refer to files but are just actions are called phony targets.&lt;/p&gt;
&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;
&lt;p&gt;If a new object file is added to the system, we might add it to one list and forget the other, such duplication is error-prone. Instead, we can do this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;objects&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;          insert.o search.o files.o utils.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;edit &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;objects&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -o edit &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objects&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;main.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c main.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;kbd.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kbd&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c kbd.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;command.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c command.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;display.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;display&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c display.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;insert.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;insert&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c insert.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;search.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;search&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c search.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;files.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;files&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c files.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;utils.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;utils&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -c utils.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;clean &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rm edit &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objects&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Other examples of using variables:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; one two &lt;span class=&#34;c1&#34;&gt;# a is assigned to the string &amp;#34;one two&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;all&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;printf&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;$a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; dude
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;all&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;x&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;letting-make-deduce-the-recipes&#34;&gt;Letting make Deduce the Recipes&lt;/h3&gt;
&lt;p&gt;It is not necessary to spell out the recipes for compiling the individual C source files, because make can figure them out: it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command. For example, it will use the recipe ‘cc -c main.c -o main.o’ to compile main.c into main.o. We can therefore omit the recipes from the rules for the object files.&lt;/p&gt;
&lt;p&gt;When a ‘.c’ file is used automatically in this way, it is also automatically added to the list of prerequisites. We can therefore omit the ‘.c’ files from the prerequisites, provided we omit the recipe.&lt;/p&gt;
&lt;p&gt;Here is the entire example, with both of these changes, and a variable objects as suggested above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;objects&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; main.o kbd.o command.o display.o &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;          insert.o search.o files.o utils.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;edit &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;objects&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        cc -o edit &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objects&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;main.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;kbd.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;command.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;display.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;insert.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;search.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;files.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;command&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;utils.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;.PHONY &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;clean &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rm edit &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objects&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; &lt;/p&gt;
&lt;h2 id=&#34;2-writing-rules&#34;&gt;2. Writing Rules&lt;/h2&gt;
&lt;p&gt;Here is an example of a rule:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;foo.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;defs&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;       &lt;span class=&#34;c&#34;&gt;# module for twiddling the frobs
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;        cc -c -g foo.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Its target is foo.o and its prerequisites are foo.c and defs.h. It has one command in the recipe: ‘cc -c -g foo.c’. The recipe starts with a tab to identify it as a recipe.&lt;/p&gt;
&lt;p&gt;This rule says two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How to decide whether foo.o is out of date: it is out of date if it does not exist, or if either foo.c or defs.h is more recent than it.&lt;/li&gt;
&lt;li&gt;How to update the file foo.o: by running cc as stated. The recipe does not explicitly mention defs.h, but we presume that foo.c includes it, and that is why defs.h was added to the prerequisites.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;types-of-prerequisites&#34;&gt;Types of Prerequisites&lt;/h3&gt;
&lt;p&gt;There are two different types of prerequisites understood by GNU make: normal prerequisites, described in the previous section, and order-only prerequisites.
A normal prerequisite makes two statements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, it imposes an order in which recipes will be invoked: &lt;span style=&#34;color:orange&#34;&gt;the recipes for all prerequisites of a target will be completed before the recipe for the target is started.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Second, it imposes a dependency relationship: &lt;span style=&#34;color:orange&#34;&gt;if any prerequisite is newer than the target, then the target is considered out-of-date and must be rebuilt.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Occasionally you may want to ensure that a prerequisite is built before a target, but without forcing the target to be updated if the prerequisite is updated. Order-only prerequisites are used to create this type of relationship. Order-only prerequisites can be specified by placing a pipe symbol (|) in the prerequisites list: any prerequisites to the left of the pipe symbol are normal; any prerequisites to the right are order-only:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;targets &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;normal&lt;/span&gt;-&lt;span class=&#34;n&#34;&gt;prerequisites&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;order&lt;/span&gt;-&lt;span class=&#34;n&#34;&gt;only&lt;/span&gt;-&lt;span class=&#34;n&#34;&gt;prerequisites&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that if you declare the same file to be both a normal and an order-only prerequisite, the normal prerequisite takes precedence (since they have a strict superset of the behavior of an order-only prerequisite).
Order-only prerequisites are never checked when determining if the target is out of date; even order-only prerequisites marked as phony (see Phony Targets) will not cause the target to be rebuilt. Which means only normal-prerequisites&amp;rsquo; timestamp will checked to determine if targets needed to be recompiled or not.&lt;/p&gt;
&lt;p&gt;Consider an example where your targets are to be placed in a separate directory, and that directory might not exist before make is run. In this situation, you want the directory to be created before any targets are placed into it but, because the timestamps on directories change whenever a file is added, removed, or renamed, we certainly don’t want to rebuild all the targets whenever the directory’s timestamp changes. One way to manage this is with order-only prerequisites: make the directory an order-only prerequisite on all the targets:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;OBJDIR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; objdir
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;OBJS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;addprefix &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;OBJDIR&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/,foo.o bar.o baz.o&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OBJDIR)/%.o &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;COMPILE.c&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;OUTPUT_OPTION&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; $&amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;all&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OBJS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OBJS)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OBJDIR&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OBJDIR)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        mkdir &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;OBJDIR&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;using-wildcard-characters-in-file-names&#34;&gt;Using Wildcard Characters in File Names&lt;/h3&gt;
&lt;p&gt;Wildcard Examples:&lt;/p&gt;
&lt;p&gt;Wildcards can be used in the recipe of a rule, where they are expanded by the shell. For example, here is a rule to delete all the object files:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rm -f *.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wildcards are also useful in the prerequisites of a rule. With the following rule in the makefile, ‘make print’ will print all the ‘.c’ files that have changed since the last time you printed them:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; *.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        lpr -p &lt;span class=&#34;nv&#34;&gt;$?&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        touch print
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This rule uses print as an empty target file; see Empty Target Files to Record Events. (The automatic variable ‘$?’ is used to print only those files that have changed; see Automatic Variables.)&lt;/p&gt;
&lt;p&gt;Wildcard expansion does not happen when you define a variable. Thus, if you write this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;objects&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; *.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;then the value of the variable objects is the actual string ‘*.o’. However, if you use the value of objects in a target or prerequisite, wildcard expansion will take place there. If you use the value of objects in a recipe, the shell may perform wildcard expansion when the recipe runs. To set objects to the expansion, instead use:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-make&#34; data-lang=&#34;make&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;objects&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;wildcard *.o&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- 
## Targets
Make an all target to run multiple targets. Since this is the first rule listed, it will run by default if make is called without specifying a target.
```make
all: one two three
one:
	touch one
two:
	touch two
three:
	touch three
clean:
	rm -f one two three
```
## Multiple targets
Here $@ is an automatic variable that contains the target name. Since there are two prerequisites, the commands will be run for f1.o and f2.o.
```make
all: f1.o f2.o

f1.o f2.o:
	echo $@
# Equivalent to:
# f1.o:
#	 echo f1.o
# f2.o:
#	 echo f2.o
```
## * Wildcard
&#34;*&#34; searches your filesystem for matching filenames. It may be used in the target, prerequisites, or in the wildcard function.
```make
# Print out file information about every .c file
print: $(wildcard *.c)
	ls -la  $?
```

```make
wrong := *.o # Don&#39;t do this! &#39;*&#39; will not get expanded
right := $(wildcard *.o)

all: one two three four

# Fails, because $(wrong) is the string &#34;*.o&#34;
one: $(wrong)
# Stays as *.o if there are no files that match this pattern :(
two: *.o 
# Works as you would expect! In this case, it does nothing.
three: $(right)
# Same as rule three
four: $(wildcard *.o)
```

## Automatic Variables



Source: https://www.gnu.org/software/make/manual/html_node


 --&gt;
</description>
    </item>
    
  </channel>
</rss>
